
#include             <iarduino_HC_SR04_int.h>     //  Подключаем библиотеку iarduino_HC_SR04_int для работы с ультразвуковым датчиком HC-SR04+
#include             <Servo.h>                    //  Подключаем библиотеку Servo                для работы с сервоприводами
//                   Определяем номера выводов:
const uint8_t        pinEcho       = 2;           //  Определяем константу с номером вывода подключённым к выводу Echo датчика расстояний    (можно указывать только те выводы Arduino, которые могут работать с внешними прерываниями)
const uint8_t        pinTrig       = 3;           //  Определяем константу с номером вывода подключённым к выводу Trig датчика расстояний    (может быть любым)
const uint8_t        pinLeftTop    = 4;           //  Определяем константу с номером вывода подключённым к верхнему сервоприводу левой  ноги (может быть любым)
const uint8_t        pinRightTop   = 5;           //  Определяем константу с номером вывода подключённым к верхнему сервоприводу правой ноги (может быть любым)
const uint8_t        pinLeftBot    = 6;           //  Определяем константу с номером вывода подключённым к нижнему  сервоприводу левой  ноги (может быть любым)
const uint8_t        pinRightBot   = 7;           //  Определяем константу с номером вывода подключённым к нижнему  сервоприводу правой ноги (может быть любым)
//                   Определяем константы:
const uint8_t        cenLeftTop    = 91;         //  Определяем константу центрального угла в градусах  для верхнего сервопривода левой  ноги (по умолчанию = 100)
const uint8_t        cenRightTop   = 41;          //  Определяем константу центрального угла в градусах  для верхнего сервопривода правой ноги (по умолчанию = 80 )
const uint8_t        cenLeftBot    = 30;          //  Определяем константу центрального угла в градусах  для нижнего  сервопривода левой  ноги (по умолчанию = 60 )
const uint8_t        cenRightBot   = 121;         //  Определяем константу центрального угла в градусах  для нижнего  сервопривода правой ноги (по умолчанию = 120)
const uint8_t        maxStepSize   = 25;          //  Определяем константу размера шага в градусах поворота верхних сервоприводов (чем больше угол, тем шире шаг)
const uint8_t        maxStepHeight = 15;          //  Определяем константу высоты  шага в градусах наклона в стороны при ходьбе (чем больше угол, тем выше шаг)
const uint8_t        minDistance   = 10;          //  Определяем константу минимального расстояния в см, при котором робот должен остановиться
const uint32_t       valDelay      = 12;          //  Определяем константу обратно пропорциональную скорости движения (чем больше значение, тем медленнее скорость)
//                   Создаём объекты:
iarduino_HC_SR04_int sensor(pinTrig, pinEcho);    //  Создаём объект sensor        для работы с датчиком расстояний, указывая номера выводов Trig и Echo
Servo                servoLeftTop;                //  Создаём объект servoLeftTop  для работы с верхним левым  сервоприводом
Servo                servoRightTop;               //  Создаём объект servoRightTop для работы с верхним правым сервоприводом
Servo                servoLeftBot;                //  Создаём объект servoLeftBot  для работы с нижним  левым  сервоприводом
Servo                servoRightBot;               //  Создаём объект servoRightBot для работы с нижним  правым сервоприводом
//                   Создаём переменные:
uint8_t              valPosition   = 224;         //  Определяем переменную (движение) для хранения текущей позиции шага (счёт от 0 до 255), начальная позиция 224
 int8_t              valTurning    = 0;           //  Определяем переменную (поворот ) для пересчета размера шага в градусах поворота верхних сервоприводов (-10 - влево ... 0 - прямо ... +10 вправо)
uint8_t              maxLeftSize;                 //  Объявляем  переменную максимального размера шага в градусах поворота верхнего левого  сервопривода (чем меньше угол, тем сильнее робот будет уходить влево )
uint8_t              maxRightSize;                //  Объявляем  переменную максимального размера шага в градусах поворота верхнего правого сервопривода (чем меньше угол, тем сильнее робот будет уходить вправо)
//                   Создаём переменные для реализации алгоритма действий:
uint8_t              i = 0;                       //  Счётчик шагов
uint8_t              f = 0;                       //  Индикатор обнаружения препятствия: 0-нет препятствия, 1-препятствие появилось, 2-есть препятствие, 3-препятствие исчезло
//                                                //  Если препятствие нет, то идём прямо. Если препятствие только появилось, то начинаем поворот. Если препятствие только исчезло, то делаем несколько шагов и начинаем идти прямо
int led1 = 12;
int led2 = 13;
void setup(){
  pinMode (led1, OUTPUT);
  pinMode (led2, OUTPUT);
//  Указываем объектам сервоприводов их выводы:
    servoLeftTop. attach(pinLeftTop);             //  Указываем объекту servoLeftTop  работать с выводом pinLeftTop
    servoRightTop.attach(pinRightTop);            //  Указываем объекту servoRightTop работать с выводом pinRightTop
    servoLeftBot. attach(pinLeftBot);             //  Указываем объекту servoLeftBot  работать с выводом pinLeftBot
    servoRightBot.attach(pinRightBot);            //  Указываем объекту servoRightBot работать с выводом pinRightBot
//  Устанавливаем центральные углы сервоприводов:
    servoLeftTop. write (cenLeftTop);             //  Устанавливаем центральную позицию (угол cenLeftTop ) для сервопривода подключённого к выводу pinLeftTop
    servoRightTop.write (cenRightTop);            //  Устанавливаем центральную позицию (угол cenRightTop) для сервопривода подключённого к выводу pinRightTop
    servoLeftBot. write (cenLeftBot);             //  Устанавливаем центральную позицию (угол cenLeftBot ) для сервопривода подключённого к выводу pinLeftBot
    servoRightBot.write (cenRightBot);            //  Устанавливаем центральную позицию (угол cenRightBot) для сервопривода подключённого к выводу pinRightBot
//  Ждём адекватных ответов от датчика расстояний:
    delay(500);
    sensor.distance();
    sensor.distance();
}
void loop (){
  digitalWrite (led1, HIGH);
  digitalWrite (led2, HIGH);
//  ==============================================
//  РЕАЛИЗУЕМ АЛГОРИТМ ПОВЕДЕНИЯ ДРОЙДИКА:
    if(millis()%valDelay==0){                     //  Выполняем действие один раз в valDelay миллисекунд ...
        valPosition++;                            //  Приращаем значение переменной valPosition заставляя робота идти вперёд
//      valPosition--;                           
        if(!valPosition){i++;}                    //  Считаем шаги в переменную i
        if(sensor.distance()<=minDistance){       //  Если обнаружено препятствие (реальное расстояние до объекта возвращённое функцией sensor.distance() меньше чем указано в константе minDistance), то ...
            if(f==0){f=1;}else                    //  Если препятствий не было    (f==0), то устанавливаем индикатор i в значение 1 (препятствие появилось)
            if(f==1){f=2;}                        //  Если препятствие появилось  (f==1), то устанавливаем индикатор i в значение 2 (препятствие есть)
        }else{                                    //  Если препятствий нет        (реальное расстояние до объекта возвращённое функцией sensor.distance() больше чем указано в константе minDistance), то ...
            if(f==1){f=3; i=0;}else               //  Если препятствие появилось  (f==1), то устанавливаем индикатор i в значение 3 (препятствие исчезло) и сбрасываем счётчик шагов
            if(f==2){f=3; i=0;}else               //  Если препятствие было       (f==2), то устанавливаем индикатор i в значение 3 (препятствие исчезло) и сбрасываем счётчик шагов
            if(f==3 && i>2){f=0;}                 //  Если препятствие исчезло    (f==1) и робот совершил более 2 шагов в сторону (i>2), то сбрасываем индикатор i в значение 0 (препятствий нет)
        }
        if(f==0){valTurning=0;}else               //  Если препятствий нет        (f==0), то не поворачиваем
        if(f==1){                                 //  Если препятствие появилось  (f==1), то ...
            if(valPosition>127){valTurning= 10;}  //  Если вперёд шла левая  нога (valPosition>127), то начинаем поворачивать вправо (если требуется повернуть более мягко, то присваиваем переменной valTurning значение ниже  10 )
            else               {valTurning=-10;}  //  Если вперёд шла правая нога (valPosition<128), то начинаем поворачивать влево  (если требуется повернуть более мягко, то присваиваем переменной valTurning значение выше -10 )
        }
    }
//  ==============================================
//  Шагаем:             Движение осуществляется в соответствии со значениями переменных: valPosition и valTurning
//                      Если значение переменной valPosition приращается, то робот будет идти вперёд
//                     
//                      Чем быстрее выполняется приращение/убавление переменной valPosition, тем быстрее шагает робот
//                      Значение переменной valTurning управляет поворотом робота, 0-прямо, 1-прямо и чуть правее, (чем выше значение - тем круче поворот), 10 поворот вправо на месте.
//                      Отрицательные значения переменной valTurning действуют аналогично положительным, но поворот осуществляется влево.
                        maxLeftSize =maxStepSize; if(valTurning<0){maxLeftSize =map(valTurning, 0,-10, maxStepSize, 0);} // Корректируем значение maxLeftSize  в соответствии со значением valTurning
                        maxRightSize=maxStepSize; if(valTurning>0){maxRightSize=map(valTurning, 0, 10, maxStepSize, 0);} // Корректируем значение maxRightSize в соответствии со значением valTurning
//                      Полный шаг каждой ноги разбит на 4 сектора в соответствии со значением переменной valPosition
//                      Каждая нога последовательно выполняет определённое движение для каждого сектора: вверх, вперёд, вниз, назад.
    if(valPosition<64 ){servoLeftTop. write(map(valPosition,   0,  63, cenLeftTop  - maxLeftSize      , cenLeftTop  + maxLeftSize     ));      // Левая  нога поворачивается вправо => отходит    назад
                        servoRightTop.write(map(valPosition,   0,  63, cenRightTop - maxRightSize     , cenRightTop + maxRightSize    ));}else // Правая нога поворачивается вправо => выходит    вперёд
    if(valPosition<128){servoLeftBot. write(map(valPosition,  64, 127, cenLeftBot  - maxStepHeight    , cenLeftBot  +(maxStepHeight/2)));      // Левая  нога наклоняется    вправо => переносит  центр тяжести с себя на правую ногу, которая станет опорной
                        servoRightBot.write(map(valPosition,  64, 127, cenRightBot -(maxStepHeight/2) , cenRightBot + maxStepHeight   ));}else // Правая нога наклоняется    вправо => опускается вниз (становится опорной) и поднимает левую ногу
    if(valPosition<192){servoLeftTop. write(map(valPosition, 128, 191, cenLeftTop  + maxLeftSize      , cenLeftTop  - maxLeftSize     ));      // Левая  нога поворачивается влево  => выходит вперёд
                        servoRightTop.write(map(valPosition, 128, 191, cenRightTop + maxRightSize     , cenRightTop - maxRightSize    ));}else // Правая нога поворачивается влево  => отходит назад
    /*valPosition<255*/{servoLeftBot. write(map(valPosition, 192, 255, cenLeftBot  +(maxStepHeight/2) , cenLeftBot  - maxStepHeight   ));      // Левая  нога наклоняется    влево  => опускается вниз (становится опорной) и поднимает правую ногу
                        servoRightBot.write(map(valPosition, 192, 255, cenRightBot + maxStepHeight    , cenRightBot -(maxStepHeight/2)));}     // Правая нога наклоняется    влево  => переносит  центр тяжести с себя на левую ногу, которая станет опорной
//  ==============================================
}
